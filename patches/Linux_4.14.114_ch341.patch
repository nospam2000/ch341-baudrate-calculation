diff --git a/drivers/usb/serial/ch341.c b/drivers/usb/serial/ch341.c
index 578596d30..9748f607f 100644
--- a/drivers/usb/serial/ch341.c
+++ b/drivers/usb/serial/ch341.c
@@ -54,8 +54,7 @@
 /*******************************/
 /* baudrate calculation factor */
 /*******************************/
-#define CH341_BAUDBASE_FACTOR 1532620800
-#define CH341_BAUDBASE_DIVMAX 3
+#define CH341_OSC_FREQ    (12000000UL)
 
 /* Break support - the information used to implement this was gleaned from
  * the Net/FreeBSD uchcom.c driver by Takanori Watanabe.  Domo arigato.
@@ -68,7 +67,10 @@
 #define CH341_REQ_MODEM_CTRL   0xA4
 
 #define CH341_REG_BREAK        0x05
+#define CH341_REG_BPS_PRE      0x12
+#define CH341_REG_BPS_DIV      0x13
 #define CH341_REG_LCR          0x18
+#define CH341_REG_LCR2         0x25
 #define CH341_NBREAK_BITS      0x01
 
 #define CH341_LCR_ENABLE_RX    0x80
@@ -98,6 +100,22 @@ struct ch341_private {
 	u8 lcr;
 };
 
+struct ch341_prescalers {
+	u8 reg_value;
+	u32 prescaler_divisor;
+};
+static const struct ch341_prescalers prescaler_table[] = {
+	{ 7, 1 },
+	{ 3, 2 },
+	{ 6, 8 },
+	{ 2, 16 },
+	{ 5, 64 },
+	{ 1, 128 },
+	{ 4, 512 },
+	{ 0, 1024 }
+};
+#define PRESCALER_TABLE_SIZE (sizeof(prescaler_table) / sizeof(prescaler_table[0]))
+
 static void ch341_set_termios(struct tty_struct *tty,
 			      struct usb_serial_port *port,
 			      struct ktermios *old_termios);
@@ -150,38 +168,65 @@ static int ch341_control_in(struct usb_device *dev,
 static int ch341_set_baudrate_lcr(struct usb_device *dev,
 				  struct ch341_private *priv, u8 lcr)
 {
-	short a;
+	unsigned long divisor;
+	short prescaler_index;
+	u8 divisor_regvalue;
+	unsigned long prescaler;
+	short prescaler_regvalue; 
+	bool foundDivisor;
 	int r;
-	unsigned long factor;
-	short divisor;
 
-	if (!priv->baud_rate)
+	if (priv->baud_rate < 46 || priv->baud_rate > 3030000)
 		return -EINVAL;
-	factor = (CH341_BAUDBASE_FACTOR / priv->baud_rate);
-	divisor = CH341_BAUDBASE_DIVMAX;
 
-	while ((factor > 0xfff0) && divisor) {
-		factor >>= 3;
-		divisor--;
+	/*
+	 * CH341A has 3 chained prescalers
+	 * bit 0: disable prescaler factor *8
+	 * bit 1: disable prescaler factor *64
+	 * bit 2: disable prescaler factor *2
+	 */
+	foundDivisor = false;
+	prescaler_index = 8; // illegal value, just to suppress compiler warning
+	// start with the smallest possible prescaler value to get the
+	// best precision at first match (largest mantissa value)
+	for (prescaler_index = 0; prescaler_index <= PRESCALER_TABLE_SIZE;
+			++prescaler_index) {
+		prescaler = prescaler_table[prescaler_index].prescaler_divisor;
+		divisor = (2 * CH341_OSC_FREQ / (prescaler * priv->baud_rate) + 1) / 2;
+		if (divisor <= 256 && divisor >= 9) {
+			foundDivisor = true;
+			break;
+		}
+		// the divisors from 8 to 2 are actually 16 to 4
+		// this is needed for baud rates >=1500000
+		else if (divisor <= 8 && divisor >= 4) {
+			divisor /= 2;
+			foundDivisor = true;
+			break;
+		}
 	}
 
-	if (factor > 0xfff0)
+	if (!foundDivisor)
 		return -EINVAL;
 
-	factor = 0x10000 - factor;
-	a = (factor & 0xff00) | divisor;
-
 	/*
 	 * CH341A buffers data until a full endpoint-size packet (32 bytes)
 	 * has been received unless bit 7 is set.
 	 */
-	a |= BIT(7);
-
-	r = ch341_control_out(dev, CH341_REQ_WRITE_REG, 0x1312, a);
+	prescaler_regvalue = prescaler_table[prescaler_index].reg_value | BIT(7);
+	divisor_regvalue = 256 - divisor;
+	printk("ch341.c: baud_rate %u, prescaler %lu, prescaler_regvalue 0x%x,"
+		" divisor %lu, divisor_regvalue 0x%x, foundDivisor %d\n",
+		priv->baud_rate, prescaler, prescaler_regvalue, divisor,
+		divisor_regvalue, foundDivisor);
+	r = ch341_control_out(dev, CH341_REQ_WRITE_REG,
+		(CH341_REG_BPS_DIV      << 8) | CH341_REG_BPS_PRE,
+		(divisor_regvalue << 8) | prescaler_regvalue);
 	if (r)
 		return r;
 
-	r = ch341_control_out(dev, CH341_REQ_WRITE_REG, 0x2518, lcr);
+	r = ch341_control_out(dev, CH341_REQ_WRITE_REG,
+		(CH341_REG_LCR2 << 8) | CH341_REG_LCR, lcr);
 	if (r)
 		return r;
 
